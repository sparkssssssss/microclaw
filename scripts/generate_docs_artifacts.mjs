#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const ROOT = process.cwd();

function read(file) {
  return fs.readFileSync(path.join(ROOT, file), 'utf8');
}

function writeIfChanged(file, content) {
  const abs = path.join(ROOT, file);
  fs.mkdirSync(path.dirname(abs), { recursive: true });
  const prev = fs.existsSync(abs) ? fs.readFileSync(abs, 'utf8') : null;
  if (prev !== content) {
    fs.writeFileSync(abs, content);
    return true;
  }
  return false;
}

function parseBuiltinTools() {
  const toolsDir = path.join(ROOT, 'src/tools');
  const files = fs
    .readdirSync(toolsDir)
    .filter((f) => f.endsWith('.rs'))
    .map((f) => path.join(toolsDir, f));
  const names = new Set();
  const re = /fn\s+name\s*\(\s*&self\s*\)\s*->\s*&str\s*\{\s*"([^"]+)"\s*\}/g;
  for (const file of files) {
    const text = fs.readFileSync(file, 'utf8');
    let m;
    while ((m = re.exec(text)) !== null) {
      names.add(m[1]);
    }
  }
  return [...names].sort((a, b) => a.localeCompare(b));
}

function inferSerdeDefault(typeName) {
  const t = typeName.trim();
  if (t.startsWith('Option<')) return 'null';
  if (t.startsWith('Vec<')) return '[]';
  if (t === 'String') return '""';
  if (t === 'bool') return 'false';
  if (/^u\d+$/.test(t) || /^i\d+$/.test(t) || t === 'usize' || t === 'isize') return '0';
  return '(serde default)';
}

function parseConfigDefaults() {
  const text = read('src/config.rs');

  const fnDefaults = new Map();
  const fnRe = /fn\s+(default_[a-z0-9_]+)\s*\(\)\s*->[^\{]+\{\n\s*([^\n]+)\n\}/g;
  let m;
  while ((m = fnRe.exec(text)) !== null) {
    const name = m[1];
    const value = m[2].trim().replace(/;$/, '');
    fnDefaults.set(name, value);
  }

  const structMatch = text.match(/pub struct Config \{([\s\S]*?)\n\}/);
  if (!structMatch) {
    throw new Error('Failed to parse Config struct');
  }

  const lines = structMatch[1].split('\n');
  let pending = null;
  const rows = [];

  for (const rawLine of lines) {
    const line = rawLine.trim();
    const attrDefault = line.match(/^#\[serde\(default\s*=\s*"([a-z0-9_]+)"\)\]$/i);
    if (attrDefault) {
      pending = { kind: 'fn', value: attrDefault[1] };
      continue;
    }
    if (line === '#[serde(default)]') {
      pending = { kind: 'serde' };
      continue;
    }

    const field = line.match(/^pub\s+([a-z0-9_]+):\s*([^,]+),$/i);
    if (!field) continue;

    const key = field[1];
    const typeName = field[2].trim();
    let defaultValue = '(required/no serde default)';
    let source = 'none';

    if (pending?.kind === 'fn') {
      source = pending.value;
      defaultValue = fnDefaults.get(pending.value) ?? '(unknown function default)';
    } else if (pending?.kind === 'serde') {
      source = 'serde(default)';
      defaultValue = inferSerdeDefault(typeName);
    }

    rows.push({ key, typeName, source, defaultValue });
    pending = null;
  }

  return rows;
}

function parseProviderPresets() {
  const text = read('src/setup.rs');
  const arrMatch = text.match(/const\s+PROVIDER_PRESETS:\s*&\[ProviderPreset\]\s*=\s*&\[([\s\S]*?)\n\];/);
  if (!arrMatch) {
    throw new Error('Failed to parse PROVIDER_PRESETS');
  }
  const body = arrMatch[1];
  const blockRe = /ProviderPreset\s*\{([\s\S]*?)\n\s*\},/g;
  const rows = [];
  let m;
  while ((m = blockRe.exec(body)) !== null) {
    const block = m[1];
    const id = block.match(/id:\s*"([^"]+)"/)?.[1] ?? '';
    const label = block.match(/label:\s*"([^"]+)"/)?.[1] ?? '';
    const protocolRaw = block.match(/protocol:\s*ProviderProtocol::([A-Za-z]+)/)?.[1] ?? 'OpenAiCompat';
    const base = block.match(/default_base_url:\s*"([^"]*)"/)?.[1] ?? '';
    const modelsRaw = block.match(/models:\s*&\[([\s\S]*?)\]/)?.[1] ?? '';
    const firstModel = modelsRaw.match(/"([^"]+)"/)?.[1] ?? '';

    if (!id) continue;
    rows.push({
      id,
      label,
      protocol: protocolRaw === 'Anthropic' ? 'native_anthropic' : 'openai_compatible',
      defaultBaseUrl: base || '(provider default)',
      defaultModel: firstModel || '(none)',
    });
  }
  return rows;
}

function renderToolsMd(names) {
  const lines = [];
  lines.push('# Generated Built-in Tools');
  lines.push('');
  lines.push('This file is generated by `scripts/generate_docs_artifacts.mjs`. Do not edit manually.');
  lines.push('');
  lines.push(`Total built-in tools: **${names.length}**`);
  lines.push('');
  for (const name of names) {
    lines.push(`- \`${name}\``);
  }
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function renderConfigMd(rows) {
  const lines = [];
  lines.push('# Generated Config Defaults');
  lines.push('');
  lines.push('This file is generated by `scripts/generate_docs_artifacts.mjs`. Do not edit manually.');
  lines.push('');
  lines.push('| Key | Type | Default Source | Default Value |');
  lines.push('|---|---|---|---|');
  for (const r of rows) {
    lines.push(`| \`${r.key}\` | \`${r.typeName}\` | \`${r.source}\` | \`${String(r.defaultValue).replace(/\|/g, '\\|')}\` |`);
  }
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function renderProvidersMd(rows) {
  const lines = [];
  lines.push('# Generated Provider Matrix');
  lines.push('');
  lines.push('This file is generated by `scripts/generate_docs_artifacts.mjs`. Do not edit manually.');
  lines.push('');
  lines.push('| Provider ID | Label | Protocol | Default Base URL | Default Model |');
  lines.push('|---|---|---|---|---|');
  for (const r of rows) {
    lines.push(`| \`${r.id}\` | ${r.label} | \`${r.protocol}\` | \`${r.defaultBaseUrl}\` | \`${r.defaultModel}\` |`);
  }
  lines.push('');
  return `${lines.join('\n')}\n`;
}

function withWebsiteFrontmatter(id, title, body) {
  return `---\nid: ${id}\ntitle: ${title}\n---\n\n${body}`;
}

function main() {
  const checkOnly = process.argv.includes('--check');
  const skipWebsite = process.argv.includes('--no-website');

  const tools = parseBuiltinTools();
  const configDefaults = parseConfigDefaults();
  const providers = parseProviderPresets();

  const rootOutputs = [
    {
      file: 'docs/generated/tools.md',
      content: renderToolsMd(tools),
    },
    {
      file: 'docs/generated/config-defaults.md',
      content: renderConfigMd(configDefaults),
    },
    {
      file: 'docs/generated/provider-matrix.md',
      content: renderProvidersMd(providers),
    },
  ];

  const websiteOutputs = [
    {
      file: 'website/docs/generated-tools.md',
      content: withWebsiteFrontmatter(
        'generated-tools',
        'Generated Tools',
        renderToolsMd(tools),
      ),
    },
    {
      file: 'website/docs/generated-config-defaults.md',
      content: withWebsiteFrontmatter(
        'generated-config-defaults',
        'Generated Config Defaults',
        renderConfigMd(configDefaults),
      ),
    },
    {
      file: 'website/docs/generated-provider-matrix.md',
      content: withWebsiteFrontmatter(
        'generated-provider-matrix',
        'Generated Provider Matrix',
        renderProvidersMd(providers),
      ),
    },
  ];

  const outputs = skipWebsite ? rootOutputs : [...rootOutputs, ...websiteOutputs];

  let changed = 0;
  for (const out of outputs) {
    const didChange = writeIfChanged(out.file, out.content);
    if (didChange) {
      changed += 1;
      console.log(`updated ${out.file}`);
    }
  }

  if (checkOnly && changed > 0) {
    console.error(`generated docs are out of date (${changed} files changed)`);
    process.exit(1);
  }

  if (changed === 0) {
    console.log('generated docs are up to date');
  }
}

main();
